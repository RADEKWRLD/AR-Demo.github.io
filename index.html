<!doctype html>
<html>
<head>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    <script>
        AFRAME.registerComponent('pinch-scale', {
            schema: { min: { default: 0.1 }, max: { default: 5 }, scaleFactor: { default: 1.5 } },
            
            init() {
                this.initialScale = this.el.object3D.scale.clone();
                this.currentScale = this.initialScale.clone();
                this.isPinching = false;
                this.bindMethods();
                this.addListeners();
            },

            bindMethods() {
                this.handleTouchStart = this.handleTouchStart.bind(this);
                this.handleTouchMove = this.handleTouchMove.bind(this);
                this.handleTouchEnd = this.handleTouchEnd.bind(this);
            },

            addListeners() {
                const scene = this.el.sceneEl;
                scene.addEventListener('touchstart', this.handleTouchStart);
                scene.addEventListener('touchmove', this.handleTouchMove);
                scene.addEventListener('touchend', this.handleTouchEnd);
            },

            removeListeners() {
                const scene = this.el.sceneEl;
                scene.removeEventListener('touchstart', this.handleTouchStart);
                scene.removeEventListener('touchmove', this.handleTouchMove);
                scene.removeEventListener('touchend', this.handleTouchEnd);
            },

            remove() { this.removeListeners(); },

            handleTouchStart(event) {
                if (event.touches.length === 2) {
                    this.isPinching = true;
                    this.initialDistance = this.getDistance(event.touches[0], event.touches[1]);
                }
            },

            handleTouchMove(event) {
                if (this.isPinching && event.touches.length === 2) {
                    const newDistance = this.getDistance(event.touches[0], event.touches[1]);
                    const scaleRatio = (newDistance / this.initialDistance) * this.data.scaleFactor;
                    const newScale = this.currentScale.clone().multiplyScalar(scaleRatio);

                    ['x', 'y', 'z'].forEach(axis => {
                        newScale[axis] = Math.min(Math.max(newScale[axis], this.data.min), this.data.max);
                    });
                    
                    this.el.object3D.scale.copy(newScale);
                    this.initialDistance = newDistance;
                }
            },

            handleTouchEnd() {
                this.isPinching = false;
                this.currentScale.copy(this.el.object3D.scale);
            },

            getDistance(touch1, touch2) {
                return Math.hypot(touch2.pageX - touch1.pageX, touch2.pageY - touch1.pageY);
            }
        });

        AFRAME.registerComponent('model-rotate', {
            schema: { rotationSpeed: { default: 1.5 } },
            
            init() {
                this.currentRotation = { x: 0, y: 0 };
                this.initialRotation = this.el.object3D.rotation.clone();
                this.isRotating = false;
                this.bindMethods();
                this.addListeners();
            },

            bindMethods() {
                this.handleTouchStart = this.handleTouchStart.bind(this);
                this.handleTouchMove = this.handleTouchMove.bind(this);
                this.handleTouchEnd = this.handleTouchEnd.bind(this);
            },

            addListeners() {
                const scene = this.el.sceneEl;
                scene.addEventListener('touchstart', this.handleTouchStart);
                scene.addEventListener('touchmove', this.handleTouchMove);
                scene.addEventListener('touchend', this.handleTouchEnd);
            },

            removeListeners() {
                const scene = this.el.sceneEl;
                scene.removeEventListener('touchstart', this.handleTouchStart);
                scene.removeEventListener('touchmove', this.handleTouchMove);
                scene.removeEventListener('touchend', this.handleTouchEnd);
            },

            remove() { this.removeListeners(); },

            handleTouchStart(event) {
                if (event.touches.length === 1) {
                    this.isRotating = true;
                    this.startX = event.touches[0].pageX;
                    this.startY = event.touches[0].pageY;
                }
            },

            handleTouchMove(event) {
                if (this.isRotating && event.touches.length === 1) {
                    const touch = event.touches[0];
                    this.currentRotation.y += (touch.pageX - this.startX) * 0.01 * this.data.rotationSpeed;
                    this.currentRotation.x += (touch.pageY - this.startY) * 0.01 * this.data.rotationSpeed;
                    this.applyRotation();
                    this.startX = touch.pageX;
                    this.startY = touch.pageY;
                }
            },

            handleTouchEnd() { this.isRotating = false; },

            applyRotation() {
                this.el.object3D.rotation.set(
                    this.initialRotation.x + this.currentRotation.x,
                    this.initialRotation.y + this.currentRotation.y,
                    this.initialRotation.z
                );
            }
        });
    </script>
</head>
<body style="margin: 0; overflow: hidden;">
    <a-scene vr-mode-ui="enabled: false;" loading-screen="enabled: false;" renderer="logarithmicDepthBuffer: true;"
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;" embedded>
        <a-assets>
            <a-asset-item id="animated-asset" src="assets/yellow_duck.glb"></a-asset-item>
        </a-assets>

        <a-marker preset="custom" url="assets/pattern-images.patt">
            <a-entity gltf-model="#animated-asset" class="clickable"
                pinch-scale="min: 0.1; max: 5; scaleFactor: 1.5"
                model-rotate="rotationSpeed: 1.5"></a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>
</body>
</html>
